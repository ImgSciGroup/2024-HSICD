import scipy.io as scio
import numpy as np
import cv2
import matplotlib.pyplot as plt
import scipy.io as scio
r=cv2.imwrite()#please input the Change magnitude images that is obtained after NSST fusing
beita =200
r= np.uint8((r-r.min())/(r.max() - r.min())*255)
ret, th = cv2.threshold(np.uint8(r), 0, 255, cv2.THRESH_OTSU + cv2.THRESH_BINARY)#initial binary map is generated by otsu.
# if the code is false,please use otsu,and the final result between markov and otsu is similar.
r = r.astype(float)
Y = (r - np.min(r)) / (np.max(r) - np.min(r))
T_yuzhi = ret / 255
bianhua = Y > T_yuzhi

u = r + 1
bianhua = 1 * bianhua
U_m0 = np.zeros(r.shape)
U_m1 = np.zeros(r.shape)
window0 = (bianhua == 0)
window1 = (bianhua == 1)
for i in range(r.shape[0]):
    for j in range(r.shape[1]):
        pixel_up = u[max(i - 1, 0), j]
        label_up = bianhua[max(i - 1, 0), j]
        if (label_up == 0):
            U_m0[i, j] += -(1 / (abs(pixel_up - u[i, j]) + 0.1))
        else:
            U_m1[i, j] += -(1 / (abs(pixel_up - u[i, j]) + 0.1))

        pixel_down = u[min(r.shape[0] - 1, i + 1), j]
        label_down = bianhua[min(r.shape[0] - 1, i + 1), j]
        if (label_down == 0):
            U_m0[i, j] += -(1 / (abs(pixel_down - u[i, j]) + 0.1))
        else:
            U_m1[i, j] += -(1 / (abs(pixel_down - u[i, j]) + 0.1))

        pixel_left = u[i, max(0, j - 1)]
        label_left = bianhua[i, max(0, j - 1)]
        if (label_left == 0):
            U_m0[i, j] += -(1 / (abs(pixel_left - u[i, j]) + 0.1))
        else:
            U_m1[i, j] += -(1 / (abs(pixel_left - u[i, j]) + 0.1))

        pixel_right = u[i, min(r.shape[1] - 1, j + 1)]
        label_right = bianhua[i, min(r.shape[1] - 1, j + 1)]
        if (label_right == 0):
            U_m0[i, j] += -(1 / (abs(pixel_right - u[i, j]) + 0.1))
        else:
            U_m1[i, j] += -(1 / (abs(pixel_right - u[i, j]) + 0.1))
k10 = np.sum(np.log(u) * window0) / np.sum(window0)
k11 = np.sum(np.log(u) * window1) / np.sum(window1)
k20 = np.sum(((np.log(u) - k10) ** 2) * window0) / (np.sum(window0) - 1)
k21 = np.sum(((np.log(u) - k11) ** 2) * window1) / (np.sum(window1) - 1)
XX1 = np.pad(bianhua, ((1, 1), (1, 1)), mode='edge')
a1 = (((np.log(u) - k10) ** 2 + k20 * np.log(2 * np.pi * k20)) / (2 * k20))
a2 = (((np.log(u) - k11) ** 2 + k21 * np.log(2 * np.pi * k21)) / (2 * k21))
U0 = a1 + beita * U_m0
U1 = a2 + beita * U_m1
bianhua1 = (U0 > U1)
maxiter = 100
for iter in range(maxiter):
    print(iter)
    window0 = (bianhua1 == 0)
    window1 = (bianhua1 == 1)
    k10 = np.sum(np.log(u) * window0) / np.sum(window0)
    k11 = np.sum(np.log(u) * window1) / np.sum(window1)
    k20 = np.sum(((np.log(u) - k10) ** 2) * window0) / (np.sum(window0) - 1)  # 方差未变
    k21 = np.sum(((np.log(u) - k11) ** 2) * window1) / (np.sum(window1) - 1)  # 方差变
    for i in range(r.shape[0]):

        for j in range(r.shape[1]):

            pixel_up = u[max(i - 1, 0), j]
            label_up = bianhua[max(i - 1, 0), j]
            if (label_up == 0):
                U_m0[i, j] += -(1 / (abs(pixel_up - u[i, j]) + 0.001))
            else:
                U_m1[i, j] += -(1 / (abs(pixel_up - u[i, j]) + 0.001))
            pixel_down = u[min(r.shape[0] - 1, i + 1), j]
            label_down = bianhua[min(r.shape[0] - 1, i + 1), j]
            if (label_down == 0):
                U_m0[i, j] += -(1 / (abs(pixel_down - u[i, j]) + 0.001))
            else:
                U_m1[i, j] += -(1 / (abs(pixel_down - u[i, j]) + 0.001))

            pixel_left = u[i, max(0, j - 1)]
            label_left = bianhua[i, max(0, j - 1)]
            if (label_left == 0):
                U_m0[i, j] += -(1 / (abs(pixel_left - u[i, j]) + 0.001))
            else:
                U_m1[i, j] += -(1 / (abs(pixel_left - u[i, j]) + 0.001))

            pixel_right = u[i, min(r.shape[1] - 1, j + 1)]
            label_right = bianhua[i, min(r.shape[1] - 1, j + 1)]
            if (label_right == 0):
                U_m0[i, j] += -(1 / (abs(pixel_right - u[i, j]) + 0.001))
            else:
                U_m1[i, j] += -(1 / (abs(pixel_right - u[i, j]) + 0.001))
    U0 = (((np.log(u) - k10) ** 2 - k20 * np.log(2 * np.pi * k20)) / (2 * k20)) + beita * U_m0  # +50*U_m0#   不变能量
    U1 = (((np.log(u) - k11) ** 2 - k21 * np.log(2 * np.pi * k21)) / (2 * k21)) + beita * U_m1  # +50*U_m0#- 变化能量
    bianhua2 = U0 > U1
    if (abs(bianhua2 != bianhua1).sum() <= 50):
        break
    bianhua1 = bianhua2
save_path = r'D:\text_all\\aaa.bmp'
cv2.imwrite(save_path, bianhua1.astype(np.uint8) * 255)
print('hahahha')
